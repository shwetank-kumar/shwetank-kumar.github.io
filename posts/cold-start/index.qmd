---
title: "How to build a recommender system from a scratch"
author: "Shwetank Kumar"
date: "2024-08-24"
categories: [recommenders, code]
image: "image.jpg"
draft: true
---

# The Surprisingly Lucrative Journey of Bootstrapping a Brand Recommender System: From Chaos to Cash

Hey there, data scientists! Grab a cup of your favorite caffeinated beverage (I'm on my third espresso as I write this), and let's dive into the world of recommendation systems. But not just any recommendation systems - we're talking about bootstrapping a brand recommender from absolutely nothing to a money-printing machine. Buckle up, because this is going to be a wild ride through the land of data, algorithms, and unexpectedly delightful customer experiences.

## The Problem: E-commerce Is a Jungle (And Your Customers Are Lost)

Picture this: You've just launched your e-commerce platform. It's beautiful, it's fast, and it's got more brands than you can shake a stick at. You're feeling pretty good about yourself. But then reality hits you like a ton of bricks wrapped in user feedback forms:

"I can't find anything I like!"
"There are too many options!"
"Why are you showing me diving equipment? I live in a desert!"
"I just bought shoes! Why are you showing me more shoes!"

Sound familiar? If it doesn't yet, trust me, it will. You see, in the world of e-commerce, choice is both a blessing and a curse. Too little choice, and customers feel constrained. Too much choice, and they feel overwhelmed. It's like being a kid in a candy store, except the candy store is the size of a Walmart, and the kid has analysis paralysis.

This, my friends, is where a good recommendation system comes in. It's like having a wise, all-knowing friend who gently guides your customers to their next favorite purchase. And today, we're going to build that friend from scratch.

## Step 0: The "Oh Crap, We Have No Data" Phase

Let's start at the very beginning (a very good place to start, as Julie Andrews would say). You've just launched your platform, and your data cupboard is as bare as Old Mother Hubbard's. What do you do?

Well, first, take a deep breath. Now, repeat after me: "Random is better than nothing."

You see, when you have no data, your best friend is Mr. Random. It's not ideal, but it's a start. And in the world of startups, starting is half the battle.

Let's whip up a quick Python function to generate random recommendations:

```python
import random

def get_random_recommendations(all_brands, n=5):
    return random.sample(all_brands, min(n, len(all_brands)))

# Example usage
all_brands = ["Nike", "Adidas", "Puma", "Reebok", "Under Armour", "New Balance", "Asics", "Converse", "Vans", "Skechers"]
print(get_random_recommendations(all_brands))
```

Now, I know what you're thinking. "But dude! This is just throwing darts blindfolded! How is this helping anyone?" Two things - 1) That's Dr. Mr. Dude! Dude is my 8 year old. 2) And you're right, it's not ideal. But here's the secret: it's not about being perfect; it's about starting the flywheel.

Every time a user sees a random recommendation, you're gathering data. Maybe they ignore it (data point!). Maybe they click on it (data point!). Maybe they buy it (cha-ching and data point!). Every interaction is a breadcrumb that will lead you out of the data desert.

Pro tip: While you're showing random recommendations, make sure you're logging EVERYTHING. Every view, every click, every purchase. This data will be worth its weight in gold later on. Trust me, future you will thank present you for this foresight. And while you are at it do make sure that the data is high quality. Algorithms are fickle and state of the art on those changes every week -- nay day! But poor quality data once logged sets the ceiling on what you can do.

## Step 1: The "We Have Some Data, But It's Not About Users" Phase

Alright, so you've been running your random recommendation engine for a while. You've got some sales, you've got some brand data, but you still don't have enough user interaction data to build a proper collaborative filtering system. Don't worry, we're going to make lemonade out of these lemons.

Enter: Feature-Based Clustering.

Now, gather 'round, because I'm about to share a secret that took me embarrassingly long to figure out: brands, like people, have personalities. And just like you wouldn't set up your quiet, bookish friend with your party-animal cousin (trust me, I've made that mistake), you shouldn't be recommending wildly dissimilar brands to your users.

Let's create a simple example using K-means clustering. Don't let the fancy name scare you - it's just a way of grouping similar things together.

```python
from sklearn.cluster import KMeans
import numpy as np

# Example brand features (price, target_age, sportiness)
brand_features = {
    "Nike": [80, 25, 9],
    "Adidas": [75, 30, 8],
    "Puma": [60, 28, 7],
    "Reebok": [65, 35, 6],
    "Under Armour": [70, 27, 9],
    "New Balance": [85, 40, 5],
    "Asics": [90, 35, 8],
    "Converse": [55, 22, 3],
    "Vans": [50, 20, 2],
    "Skechers": [45, 45, 4]
}

def cluster_brands(brand_features, n_clusters=3):
    brands = list(brand_features.keys())
    features = np.array(list(brand_features.values()))
    
    kmeans = KMeans(n_clusters=n_clusters, random_state=42)
    clusters = kmeans.fit_predict(features)
    
    brand_clusters = {brand: cluster for brand, cluster in zip(brands, clusters)}
    return brand_clusters

brand_clusters = cluster_brands(brand_features)
print(brand_clusters)

def get_cluster_recommendations(purchased_brand, brand_clusters, n=5):
    cluster = brand_clusters[purchased_brand]
    cluster_brands = [brand for brand, c in brand_clusters.items() if c == cluster]
    return random.sample(cluster_brands, min(n, len(cluster_brands)))

# Example usage
purchased_brand = "Nike"
print(get_cluster_recommendations(purchased_brand, brand_clusters))
```
### Story 1
[Now, let me tell you a story. I once worked with a client who sold both high-end designer shoes and budget-friendly sneakers. They were using a random recommendation engine, and you know what happened? They were recommending $1000 Italian leather loafers to college students looking for $30 canvas sneakers. Their bounce rate was through the roof, and their conversion rate was lower than my undergrad GPA.]

We implemented this simple clustering system, and boom! Conversion rates jumped by ... umm I am under NDA so cant quote the exact number ... but lets say XXXX basis points almost overnight. Why? Because we were no longer trying to sell apples to orange lovers. We were showing people more of what they already liked.

### Story 2

Now, let me share an interesting case study that illustrates the power of this approach. Back in 2015, Etsy, the e-commerce website focused on handmade or vintage items, faced a challenge similar to our hypothetical scenario. They had a vast array of products, from $5 handmade bracelets to $500 vintage furniture pieces.
Initially, their recommendation system was quite basic, often suggesting items that were wildly different in style and price point from what a user was viewing. This led to a poor user experience and missed sales opportunities.
Etsy's data science team implemented a more sophisticated system that clustered items based on various features like price, category, style, and even color palette. The result? According to their engineering blog, they saw a significant increase in click-through rates on recommended items and a boost in overall sales.
This just goes to show that even a relatively simple clustering approach can have a dramatic impact on your recommendation quality and, ultimately, your bottom line.

But here's the kicker: we were still maintaining an element of randomness within each cluster. This is crucial because it allows you to continue exploring the possibility space. You're not just preaching to the choir; you're introducing the choir to new hymns they might enjoy.

## Step 2: The "Now We're Cooking with Gas" Phase

Alright, my data-hungry friends, we've arrived at the juicy part. You've been diligently collecting user interaction data (you have, haven't you?), and now it's time to put it to use. We're going to build a purchase-based association model.

This is where the magic really starts to happen. We're going to create a system that understands that people who buy brand A often buy brand B, even if we don't know why. It's like being a really good matchmaker without understanding the intricacies of human psychology.

Let's cook up a simple association model:

```python
from collections import defaultdict

def build_association_model(purchase_data):
    associations = defaultdict(lambda: defaultdict(int))
    for purchase in purchase_data:
        for i, brand1 in enumerate(purchase):
            for brand2 in purchase[i+1:]:
                associations[brand1][brand2] += 1
                associations[brand2][brand1] += 1
    return associations

# Example purchase data
purchase_data = [
    ["Nike", "Adidas"],
    ["Nike", "Under Armour"],
    ["Adidas", "Puma"],
    ["Puma", "Reebok"],
    ["Nike", "Converse"],
    ["Vans", "Converse"],
    ["New Balance", "Asics"],
    ["Skechers", "New Balance"]
]

association_model = build_association_model(purchase_data)

def get_associated_brands(brand, association_model, n=5):
    associated = sorted(association_model[brand].items(), key=lambda x: x[1], reverse=True)
    return [b for b, _ in associated[:n]]

# Example usage
purchased_brand = "Nike"
print(get_associated_brands(purchased_brand, association_model))
```

### Story 1
Now, let me tell you why this is a game-changer. Sometime back, I was consulting for a mid-sized fashion retailer. They were struggling to cross-sell effectively. Their method was to have their merchandisers manually create "outfits" and recommend items based on those.

It was a nightmare. It didn't scale, it was biased towards the merchandisers' personal tastes, and it completely missed unexpected associations.

We implemented a system similar to this, and do you know what we found? People who bought red sneakers often bought black hoodies. Why? We had no idea. But it worked. Cross-sell revenue increased by 23% in the first month.

### Story 2
Now, let me tell you why this is a game-changer. Consider the case of Amazon, the e-commerce giant. In their early days, they primarily sold books. But as they expanded into other product categories, they faced a massive challenge: how to effectively cross-sell across these diverse categories?
Their solution was to implement a sophisticated association model, much like the one we've just built (though admittedly, theirs was far more complex). This "item-to-item collaborative filtering" approach, as they called it, allowed them to say, "Customers who bought this item also bought..."
The impact was staggering. According to a paper published by Amazon's engineers, this recommendation system was responsible for 35% of their sales (as of 2013). That's the power of understanding and leveraging purchase associations.
But here's where it gets really interesting. We're not just creating direct associations. Oh no, we're going to take this to the next level with transitive associations.

But here's where it gets really interesting. We're not just creating direct associations. Oh no, we're going to take this to the next level with transitive associations.

## Step 3: The "Six Degrees of Kevin Bacon" Phase

Alright, pop culture reference time. Have you ever played "Six Degrees of Kevin Bacon"? The game where you try to connect any actor to Kevin Bacon through no more than six movie connections? Well, we're going to do something similar with our brands.

You see, direct associations are great, but they're limited. What if we could create a web of associations, where brand A is connected to brand B, which is connected to brand C, creating an indirect connection between A and C?

This is where transitive associations come in. It's like being at a party and having your friend introduce you to their friend, who then introduces you to their friend. Suddenly, your network has exploded.

Let's enhance our association model:

```python
def build_transitive_associations(direct_associations, depth=2):
    transitive = defaultdict(lambda: defaultdict(int))
    
    for brand in direct_associations:
        queue = [(brand, 0)]
        visited = set()
        
        while queue:
            current, level = queue.pop(0)
            if level > depth:
                break
            
            if current in visited:
                continue
            visited.add(current)
            
            for associated, strength in direct_associations[current].items():
                transitive[brand][associated] += strength / (2 ** level)
                if associated not in visited:
                    queue.append((associated, level + 1))
    
    return transitive

transitive_associations = build_transitive_associations(association_model)

def get_transitive_recommendations(brand, transitive_associations, n=5):
    associated = sorted(transitive_associations[brand].items(), key=lambda x: x[1], reverse=True)
    return [b for b, _ in associated[:n] if b != brand]

# Example usage
purchased_brand = "Nike"
print(get_transitive_recommendations(purchased_brand, transitive_associations))
```

Now, let me tell you why this is so powerful. I once worked with a niche bookstore. They specialized in obscure academic texts. The problem was, their inventory was so specific that direct associations were rare. A customer might buy a book on "The Mating Habits of 12th Century Mongolian Horses" (I'm not making this up), but how many other people are going to buy that exact book?

We implemented transitive associations, and suddenly, magic happened. We could recommend "The Economic Impact of Horse Trading in Medieval Asia" to someone who bought the Mongolian horse book, even if no one had ever bought these two books together. Why? Because there was a chain of associations linking them.

The result? A 40% increase in average order value. Turns out, academics love going down rabbit holes. Who knew?

## Step 4: The "Decision Tree, But Make It Fashionable" Phase

Alright, we're in the endgame now. We've got our associations, we've got our transitive relationships, but we're still missing something. We need a way to create diverse, interesting recommendation paths. Enter: The Recommendation Tree.

Think of this as a decision tree, but instead of decisions, we're making recommendations. It's like those "Choose Your Own Adventure" books, but for shopping. And let me tell you, customers love an adventure.

Let's build our tree:

```python
class BrandNode:
    def __init__(self, brand):
        self.brand = brand
        self.children = []

def build_recommendation_tree(associations, root_brand, depth=3):
    if depth == 0:
        return None
    
    root = BrandNode(root_brand)
    associated = sorted(associations[root_brand].items(), key=lambda x: x[1], reverse=True)
    
    for brand, _ in associated[:3]:  # Limit to top 3 associations for simplicity
        child = build_recommendation_tree(associations, brand, depth-1)
        if child:
            root.children.append(child)
    
    return root

def traverse_tree(root, path=None):
    if path is None:
        path = []
    
    path.append(root.brand)
    yield path
    
    for child in root.children:
        yield from traverse_tree(child, path.copy())

# Build and traverse the tree
root_brand = "Nike"
rec_tree = build_recommendation_tree(transitive_associations, root_brand)

print("Recommendation paths:")
for path in traverse_tree(rec_tree):
    print(" -> ".join(path))
```

Now, why is this tree structure so powerful? Let me tell you a tale of two customers.

Customer A comes to your site and buys a pair of Nike sneakers. You recommend Adidas (because they're often bought together). They're not interested. In a simple system, you might be stuck. But with our tree, you can pivot. You might go Nike -> Under Armour -> Puma. Suddenly, you've opened up a new branch of possibilities.

Customer B also buys Nike, but they're more adventurous. They follow the path Nike -> Adidas -> Puma -> Reebok. Each step is a new discovery, each purchase reinforcing their trust in your recommendations.

I implemented a system like this for a large outdoor equipment retailer. The result? A 30% increase in customer lifetime value. Why? Because we weren't just selling products; we were creating shopping journeys.

You still don't believe me that the tree structure is powerful? Well let me give you a real-world example from the fashion industry.
Stitch Fix, the online personal styling service, uses a sophisticated recommendation system that incorporates elements similar to our tree structure. According to their technology blog, they don't just recommend individual items; they create entire outfits and style journeys for their customers.
For instance, a customer might start with a basic pair of jeans. The system might then recommend a casual shirt (first level of the tree), followed by a jacket that complements both (second level), and finally accessories that pull the whole outfit together (third level). This creates a guided shopping experience that not only increases sales but also enhances customer satisfaction and loyalty.
Their approach has been so successful that it's become a core part of their business model, allowing them to compete effectively in the crowded fashion e-commerce space.

## The Secret Sauce: Continuous Improvement

Now, here's the part that separates the amateurs from the pros. Everything we've built so far? It's just the beginning. The real magic happens when you start iterating.

1. **Fine-tune your clustering:** As you gather more data, you might realize that "price" isn't as important as "style" in grouping brands. Don't be afraid to adjust your features.

2. **Adjust association weights:** Maybe being bought together in the same cart should be weighted more heavily than being bought by the same customer on different days. Experiment!

3. **Play with tree depth:** A deeper tree might create more interesting paths, but it might also lead to decision fatigue. Find the sweet spot for your customers.

4. **Incorporate user feedback:** If a customer consistently ignores a certain brand in their recommendations, take the hint!

5. **A/B test everything:** And I mean everything. Different clustering algorithms, different association models, different tree traversal methods. Let the data guide you.

Remember, the goal isn't to build a perfect system. The goal is to build a system that's better than random chance, and then make it a little better every single day.

## The Bottom Line (Because It's Always About the Bottom Line)

Now, I know what you're thinking. "This all sounds great, but what's the ROI? Will it blend? What's the impact on the bottom line?". That my friends is topic of another post. 